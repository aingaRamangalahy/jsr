name: Deploy to VPS

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      - name: Deploy to VPS
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            cd apps/jsr
            
            # Force clean git update
            git fetch origin
            git reset --hard origin/master
            
            echo "Ensuring we have the latest code..."
            # Verify Dockerfile has the correct content with error handling for all services
            grep -q "cd backend && pnpm build || echo \"Ignoring TypeScript errors in backend\"" Dockerfile || echo "WARNING: Dockerfile does not contain expected backend build commands!"
            grep -q "cd frontend && pnpm build || echo \"Ignoring TypeScript errors in frontend\"" Dockerfile || echo "WARNING: Dockerfile does not contain expected frontend build commands!"
            grep -q "cd admin && pnpm build || echo \"Ignoring TypeScript errors in admin\"" Dockerfile || echo "WARNING: Dockerfile does not contain expected admin build commands!"
            
            # Make sure .env file exists for Docker Compose to use
            if [ ! -f .env ]; then
              echo "Creating .env file from template"
              cp env.example .env
              
              # Set required environment variables
              sed -i "s|MONGODB_ATLAS_URI=.*|MONGODB_ATLAS_URI=${{ secrets.MONGODB_ATLAS_URI }}|g" .env
              sed -i "s|JWT_SECRET=.*|JWT_SECRET=${{ secrets.JWT_SECRET }}|g" .env
              sed -i "s|SUPABASE_URL=.*|SUPABASE_URL=${{ secrets.SUPABASE_URL }}|g" .env
              sed -i "s|SUPABASE_ANON_KEY=.*|SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}|g" .env
              sed -i "s|SUPABASE_SERVICE_ROLE_KEY=.*|SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}|g" .env
              sed -i "s|API_URL=.*|API_URL=https://api.jsresources.dev|g" .env
              sed -i "s|DOMAIN_NAME=.*|DOMAIN_NAME=jsresources.dev|g" .env
              sed -i "s|ADMIN_EMAIL=.*|ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}|g" .env
              sed -i "s|NODE_ENV=.*|NODE_ENV=production|g" .env
            else
              # Update the .env file with the latest production values
              sed -i "s|MONGODB_ATLAS_URI=.*|MONGODB_ATLAS_URI=${{ secrets.MONGODB_ATLAS_URI }}|g" .env
              sed -i "s|JWT_SECRET=.*|JWT_SECRET=${{ secrets.JWT_SECRET }}|g" .env
              sed -i "s|SUPABASE_URL=.*|SUPABASE_URL=${{ secrets.SUPABASE_URL }}|g" .env
              sed -i "s|SUPABASE_ANON_KEY=.*|SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}|g" .env
              sed -i "s|SUPABASE_SERVICE_ROLE_KEY=.*|SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}|g" .env
              sed -i "s|NODE_ENV=.*|NODE_ENV=production|g" .env
            fi
            
            # Create Nginx config files if they don't exist
            if [ ! -f "frontend/nginx.conf" ] && [ -f "frontend/nginx.conf.template" ]; then
              cp frontend/nginx.conf.template frontend/nginx.conf
            fi

            if [ ! -f "admin/nginx.conf" ] && [ -f "admin/nginx.conf.template" ]; then
              cp admin/nginx.conf.template admin/nginx.conf
            fi
            
            # Free up resources before building
            echo "Stopping previous containers to free resources..."
            docker compose -f docker-compose.prod.yml down
            
            # Aggressive cleanup of Docker cache and resources
            echo "Aggressive cleaning of Docker resources..."
            docker system prune -af --volumes
            docker builder prune -f
            docker image prune -af
            
            # Enable BuildKit for more efficient builds
            echo "Setting up Docker BuildKit..."
            export DOCKER_BUILDKIT=1
            export DOCKER_DEFAULT_PLATFORM=linux/amd64
            
            # Build the full stack with forced rebuild, no cache
            echo "Building containers with clean forced rebuild..."
            docker compose -f docker-compose.prod.yml build --no-cache --progress=plain
            
            echo "Starting all containers..."
            docker compose -f docker-compose.prod.yml up -d
            
            # Update Nginx configuration if needed - handle without sudo password prompts
            if [ -f nginx-host-config.conf ]; then
              echo "Nginx configuration found. Creating deployment script..."
              
              # Create update_nginx.sh script line by line
              echo '#!/bin/bash' > update_nginx.sh
              echo '# Nginx configuration update script' >> update_nginx.sh
              echo 'cp nginx-host-config.conf /etc/nginx/sites-available/jsresources' >> update_nginx.sh
              echo '' >> update_nginx.sh
              echo 'if [ ! -f /etc/nginx/sites-enabled/jsresources ]; then' >> update_nginx.sh
              echo '  ln -s /etc/nginx/sites-available/jsresources /etc/nginx/sites-enabled/' >> update_nginx.sh
              echo 'fi' >> update_nginx.sh
              echo '' >> update_nginx.sh
              echo 'if [ -f /etc/nginx/sites-enabled/default ]; then' >> update_nginx.sh
              echo '  rm /etc/nginx/sites-enabled/default' >> update_nginx.sh
              echo 'fi' >> update_nginx.sh
              echo '' >> update_nginx.sh
              echo 'if ! certbot certificates | grep -q "admin.jsresources.dev"; then' >> update_nginx.sh
              echo '  # Use --expand flag to add new domains to existing certificate' >> update_nginx.sh
              echo '  certbot --nginx --expand --non-interactive --agree-tos -d jsresources.dev -d api.jsresources.dev -d admin.jsresources.dev' >> update_nginx.sh
              echo 'fi' >> update_nginx.sh
              echo '' >> update_nginx.sh
              echo 'systemctl reload nginx' >> update_nginx.sh
              
              chmod +x update_nginx.sh
              
              # Try to use passwordless sudo if it's configured
              echo "Attempting to update Nginx with passwordless sudo..."
              if sudo -n true 2>/dev/null; then
                # Passwordless sudo is available, try to run the script
                echo "Passwordless sudo is available, updating Nginx configuration..."
                sudo ./update_nginx.sh && echo "Nginx configuration updated successfully!" || echo "Failed to update Nginx configuration with sudo."
              else
                # Passwordless sudo is not available, provide instructions
                echo "======================================================"
                echo "NGINX CONFIGURATION UPDATE REQUIRED"
                echo "======================================================"
                echo "Please run the following command manually with sudo privileges:"
                echo "sudo ./update_nginx.sh"
                echo ""
                echo "To enable automatic updates in future deployments, set up passwordless sudo for these specific commands:"
                echo ""
                echo "Run: sudo visudo"
                echo "Add the following line (replace username with your username):"
                echo "username ALL=(ALL) NOPASSWD: /bin/cp */nginx-host-config.conf /etc/nginx/sites-available/jsresources, /bin/ln -s /etc/nginx/sites-available/jsresources /etc/nginx/sites-enabled/, /bin/rm /etc/nginx/sites-enabled/default, /usr/bin/certbot, /bin/systemctl reload nginx"
                echo "======================================================"
              fi
            fi
            
            # Final disk space check
            df -h /
          ENDSSH